# 데이터 구조



### 문자열

* Immutable

* Iterable

* ordered

  * 첫번쨰 인덱스는 0부터 시작, 마지막꺼는 -1로 불러 올 수 있음.
  * s[start:stop:step]

* 메소드

  * .find(x)

    * x의 첫 번째 위치를 반환. 없으면 -1을 반환

    ```python
    'apple'.find('p')         # 1
    ```

  * .index()

    * x의 첫 번째 위치를 반환. 없으면 `ValueError` 일으킴

    ```python
    'apple'.index(x)   # ValueError
    ```

  * .replace(old, new [,count])

    * 바꿀 대상 글자를 새로운 글자로 바꿔서 반환 (복사본 반환)
    * count를 지정하면, 해당 개수만큼만 시행

    ```python
    'conne'.replace('o','a')
    # caane
    
    'wooooowoo'.replace('o','!',2)
    #w!!ooowoo
    ```

  * .strip([chars])

    * 특정한 문자를 지정하면,

      * 양쪽을 제거하거나(strip), 왼쪽을 제거하거나(lstrip), 오른쪽을 제거(rstrip)

    * 문자열을 지정하지 않으면 공백을 제거함

      ```python
      
      
      ```

  * .split(sep=None)

    * 문자열을 특정한 단위로 나눠 리스트로 반환

      ```python
      'a,'b','c'.split('_')
      # ['a,b,c']
      
      'a b c'.split()
      #['a','b','c']
      ```

  * .join(iterable)

    * 반복 가능한(iterable) 컨테이너 요소들을 separatror(구분자)로 합쳐 문자열 반환

    ```python
    '!'.join('ssafy')
    # 's!s!a!f!y'
    
    ' '.join['3', '5']
    # '3 5'
    
    ```

  * .caplitalize() : 앞글자를 대문자로 변환

  * .title() : `'` 나 공백 이후의 단어 첫 문자를 대문자로

  * .upper() : 모두 대 문자로

  * .lower() : 모두 소문자로

  * .swapcase() :  대<->소문자로 변경

  * .Isalpha() : 알파벳 문자 여부

  * .Issuer() : 대문자 여부

  * .islower() : 소문자 여부

  * .istitle() : 타이틀 형식 여부
  
  * .isdecimal(): int로 변환 되면 True
  
  * .isdigit() : 숫자 형태로 보이면 True
  
  * .isnumeric() : 의마가 숫자와 통한다면. 로마 숫자도 True로 반환, 한자 일이삼도 True로 반환
  
  * .isspace() : 문자열이 공백으로만 구성되어있으면 True반환. 그렇지 않으면 False

![image-20210726100846966](데이터 구조.assets/image-20210726100846966.png)

### 리스트

* 순서가 있는 시퀀스, 인덱스로 접근

* 문자열의 특징

  * 변경 가능(mutable)
  * ordered
  * iterable

* 메소드

  * .append(x)

    * 리스트에 값을 추가함

    * 해당 값을 그대로 추가
  
      ```python
      cafe = ['starbucks','tomntoms','hollys']
      
      cafe.append('banapresso')
      cafe.append(['coffee'])
      print(cafe)
      # ['starbucks','tomntoms','hollys','banapresso',['coffee']]
      ```
  
  * .extend
  
    * 리스트에 iterable의 항목을 추가함
  
      ```python
      cafe = ['starbucks','tomntoms','hollys']
      
      cafe.extend(['coffee'])
      print(cafe)
      # ['starbucks','tomntoms','hollys','coffee']
      
      cafe.extend('coffee')
      print(cafe)
      ['starbucks','tomntoms','hollys','c','o','f','f','e','e']
      ```
  
  * .remove(x)
  
    * 리스트에서 값이 x인것 삭제
  
      ```python
      numbers = [1,2,3,'hi']
      numbers.remove('hi')
      print(numbers)
      # [1,2,3]
      ```
  
  * .pop(i)

    * 정해진 위치 i에 있는 값을 삭제하고, 그 항목을 반환함
    * i가 지정되지 않으면, 마지막 항목을 삭제하고 반환함
  
    ```python
    numbers = ['hi',1,2,3]
    numbers.pop()
    print(numbers)
    # ['hi',1,2]
    ```
  
  * .clear()
  
    * 모든 항목을 삭제
  
    ```python
    numbers = ['hi',1,2,3]
    numbers.clear()
    print(numbers)
    # []
    ```
  
  * .index(x)

    * x값을 찾아 해당 index값을 반환
    * x값이 없으면 ValueError 발생
  
    ```python
    numbers = ['hi',1,2,3]
    print(numbers.index(1))
    # 1
    ```
  
  * .count(x)

    * 원하는 값의 개수를 반환함
    * 없으면 0을 반환
  
    ```python
    numbers = ['hi',1,2,3,1]
    print(numbers.count(1))
    # 2
    ```
  
  * .sort()

    * 원하는 리스트를 정렬함. None 반환, 원본을 변경
    * sorted 함수는 원본 변경x, 반환o
  
    ```python
    numbers = [3,2,5,1]
    result = numbers.sort()
    print(numbers, result)
    # [1, 2, 3,5] None     원본 변경
    
    numbers = [3,2,5,1]
    result = sorted(numbers)
    print(numbers, result)
    #[3,2,5,1] [1,2,3,5] 정렬된 리스트를 반환. 원본 변경 없음
    ```
  
  * .reverse()
  
    * 순서를 반대로 뒤집음(정렬하는 것이 아님, 배열만 뒤집는것)
  
    ```python
    numbers = [3,2,5,1]
    result = numbers.reverse()
    print(numbers, result)
    
    #[1,5,2,3]  None
    ```
  
  #### 리스트 복사
  
  ```python
  original_list = [1,2,3]
  copy_list = original_list
  print(original_list, copy_list)
  
  # [1,2,3]  [1,2,3]
  
  copy_list[0] = 'hello'
  print(original_list, copy_list)
  # ['hello',2,3] ['hello',2,3]
  
  해당 주소의 일부 값을 변경하는 경우 이를 참조하는 모든 변수에 영향
  ```



* 얕은 복사(shallow copy)

  * Slice 연산자 활용하여 같은 원소를 가진 리스트지만 연산된 결과를 복사 (다른 주소)

    ```python
    a = [1,2,3]
    b = a[:]
    print(a,b)
    b[0] = 5
    print(a,b)
    
    # [1,2,3] [1,2,3]
    # [1,2,3] [5,2,3]
    ```

  * List()를 활용하여 같은 원소를 가진 리스트지만 연산된 결과를 복사 (다른주소)

    ```python
    a = [1,2,3]
    b = list(a)
    print(a,b)
    b[0] = 5
    print(a,b)
    
    # [1,2,3] [1,2,3]
    # [1,2,3] [5,2,3]
    ```

  * 복사하는 리스트의 원소가 주소를 참조하는 경우

    * 가장 큰 리스트는 복사가 되었지만 그 안의 리스트는 되지 않은 경우

    ```python
    a = [1,2['a','b']]
    b = [a:]
    print(a,b)
    b[2][0]=0
    print(a,b)
    
    # [1,2['a','b']] [1,2['a','b']]
    # [1,2[0,'b']] [1,2[0,'b']]
    ```

* 깊은 복사(Deep copy)

  ``` python
  import copy
  a = [1,2['a','b']]
  b = copy.deepcopy(a)
  print(a,b)
  b[2][0]=0
  print(a,b)
  
  # [1,2['a','b']] [1,2['a','b']]
  # [1,2['a','b']] [1,2[0,'b']]
  ```



#### List comprehension

* 표현식과 제어문을 통해 특정한 값을 가진 리스트를 생성하는 법

  [<experssion> for <변수> in <iterable>]

  [<expression> for <변수> in <iterable> if <조건식>]

  * 효율적이긴 하나 다른사람이 봤을 때 이해하기 어렵다는 단점이 있음.
  
  ```python
  # 1~3의 세제곱 리스트 만들기
  cubic_list = []
  for number in range(1,4):
    cubic_list.append(number ** 3)
  cubic_list
  
  # list comprehension 사용
  [number **3 for number in range(1,4)]
  ```
  
  ```python
  even_list = []
  for i in range(1,4):
    if i % 2 =0:
      even_list.append(i)
  
  
  [x for x in range(1,4) if x % 2 ==0]
  ```
  
  ```python
  girls = ['jane','ashely']
  boys = ['justin', 'eric']
  
  pair = []
  for boy in boys:
    for girl in girls:
      pair.append((boy,girl))
  
  [(boy,girl for boy in boys for girl in girls)]
  # [('justin','jane'),
  #	 ('justin','ashely'),
  #  ('eric','jane'),
  #  ('eirc','ashely')]



#### Built-in Function - map

* map(function, iterable)

  * 순회 가능한 데이터 구조(iterable)의 모든 요소에 함수(function)적용하고, 그 결과를 map object로 반환

  ```python
  numbers = [1,2,3]
  result = map(str, numbers)
  a = list(result)
  print(a)
  
  #['1','2','3']
  ```

  * 알고리즘 문제 풀이시 input 값들을 숫자로 바로 활용하고 싶을 때

  ```python
  n, m = map(int, input().split())
  ```



* Filter(function, iterable)

  * 순회 가능한 데이터구조의 모든요소에 함수 적용하고 그 결과가 True인 것들을 filter object로 반환

  ```python
  def odd(n):
    return n % 2
  numbers =[1,2,3]
  result = filter(odd, numbers)
  print(result, type(result))
  a = list(result)
  print(a)
  
  #[1,3]
  ```

* zip(*iterables)

  * 복수의 iterable을 모아 튜플을 원소로 하는 zip object를 반환

  ```python
  girls = ['jane','ashely']
  boys = ['justin','eric']
  pair = zip(girls,boys)
  a= list(pair)
  print(a)
  
  #[('jane','justin'),('ahsely','eric')]
  ```



#### Set

* 중복, 순서가 없는 데이터 구조

* 문자열의 특징

  * mutable
  * unordered
  * iterable

* 메소드

  * .add(elem)

  ```python
  a = {'사과','바나나','수박'}
  a.add('딸기')
  print(a)
  
  # {'바나나','사과','딸기','수박'}
  ```

  * .update(*others)
    * 여러 값을 추가

  ```python
  a = {'사과','바나나','수박'}
  a.add('딸기','바나나','참외')
  print(a)
  
  # {'바나나','사과','참외','수박','딸기'}
  ```

  

  * .remove
    * 세트에서 삭제하고, 없으면 KeyError
  * .discard(elem)
    * 세트에서 삭제하고 없어도 에러가 발생하지 않음
  * .pop()
    * 임의의 원소를 제거해 반환

  ```python
  a = {'사과','바나나','수박'}
  a.pop()
  print(a)
  # {'사과','수박'}
  ```



#### 딕셔너리

* Key와 Value로 구성된 데이터 구조
* 딕셔너리의 특징
  * mutable
  * unordered
  * iterable
* 메소드
  * .get(key[,default])
    * key에 대응하는  value를 가져옴
    * key가 딕셔너리에 없어도 keyError가 발생하지 않으며, default를 돌려줌 (기본: None)

![image-20210726110950723](데이터 구조.assets/image-20210726110950723.png)

* .pop(key[,defautl])

  * key가 딕셔너리에 있으면 제거하고 해당 값을 반환

  * 그렇지 않으면 default를 반환

  * default값이 없으면 KeyError

    ![image-20210726111246313](데이터 구조.assets/image-20210726111246313.png)

![image-20210726111304783](데이터 구조.assets/image-20210726111304783.png)

* .update()

  * 값을 제공하는 key, value로 덮어씁니다

    ![image-20210726111341839](데이터 구조.assets/image-20210726111341839.png)

* Dictionary Comprehension

  * {key: value for < 변수> in <iterable>}
  * {key: value for <변수> in <iterable> if <조건식>}

  ```python
  dusts = {'서울':72, '대전':82, '구미':29, '광주': 45}
  
  result ={}
  for key, value in dusts.items():
    if value >70:
      result[key] = value
  print(result)
  
  
  {key:value for key, value in dusts if value >70}
  ```

  

